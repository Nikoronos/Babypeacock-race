<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Babypeacock Meteor Match - Swipe S√ºr√ºm√º</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box;}
    body{
      background:#020012;
      color:#fff;
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      min-height:100vh;
      display:flex;
      justify-content:center;
      align-items:flex-start; /* √ústten ba≈ülasƒ±n */
      padding:10px;
      overscroll-behavior: none; /* Mobil refresh engelleme */
    }
    .wrap{
      width:100%;
      max-width:480px;
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:center;
    }

    /* BA≈ûLIK */
    .title{
      text-align:center;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .title h1{
      font-size:22px;
      font-weight:900;
      letter-spacing:.03em;
    }
    .title span{
      font-size:11px;
      opacity:.9;
    }
    .badge{
      margin-top:2px;
      padding:4px 10px;
      border-radius:999px;
      background:rgba(0,0,0,.8);
      font-size:9px;
      display:inline-flex;
      gap:5px;
      align-items:center;
    }
    .badge strong{color:#ffce3a;}

    /* K√ñPEK PROGRESS BAR */
    .race-wrap{
      width:100%;
      margin-top:4px;
    }
    .race-label{
      font-size:10px;
      display:flex;
      justify-content:space-between;
      gap:6px;
      margin-bottom:4px;
    }
    .race-label span strong{color:#ffce3a;}
    .race-bar{
      position:relative;
      width:100%;
      height:40px;
      border-radius:20px;
      padding:4px 8px;
      background:
        radial-gradient(circle at 0 0,rgba(255,255,255,.15),transparent 55%),
        linear-gradient(to right,#021723,#273b70,#ff4e4e);
      box-shadow:0 8px 20px rgba(0,0,0,.9);
      overflow:hidden;
    }
    .finish-tag{
      position:absolute;
      right:6px;
      top:6px;
      padding:2px 8px;
      border-radius:999px;
      font-size:9px;
      background:rgba(0,0,0,.85);
      border:1px solid #ffce3a;
      color:#ffce3a;
    }
    .doge-marker{
      position:absolute;
      left:6px;
      bottom:4px;
      width:40px;
      height:32px;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      background:transparent;
      transition:transform .22s ease-out;
      z-index: 2;
    }
    .doge-marker video{
      height:30px;
      border-radius:999px;
      display:block;
    }

    /* TAHTA KARTI */
    .board-wrap{
      margin-top:8px;
      padding:10px;
      border-radius:20px;
      background:
        radial-gradient(circle at 0 0,rgba(255,255,255,.08),transparent 70%),
        radial-gradient(circle at 100% 100%,rgba(120,119,198,.15),transparent 70%);
      box-shadow:0 12px 28px rgba(0,0,0,.95);
    }
    .top-row{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:6px;
      font-size:10px;
      margin-bottom:4px;
    }
    #score{color:#ffce3a;font-weight:700;}
    #moves{color:#7dffb4;font-weight:700;}

    /* HEDEF SATIRI */
    .targets{
      margin-bottom:4px;
      font-size:10px;
      display:flex;
      flex-wrap:wrap;
      gap:4px;
      align-items:center;
    }
    .targets-title{
      opacity:.9;
      margin-right:4px;
    }
    .target-pill{
      padding:2px 7px;
      border-radius:999px;
      background:rgba(0,0,0,.75);
      display:inline-flex;
      align-items:center;
      gap:4px;
    }
    .target-dot{
      width:9px;
      height:9px;
      border-radius:50%;
    }
    .dot-r{background:#ff3b3b;}
    .dot-y{background:#ffe45d;}
    .targets-sub{
      font-size:9px;
      opacity:.7;
      margin-left:auto;
    }

    /* OYUN ALANI */
    .board{
      width:100%;
      max-width:360px;
      aspect-ratio:1/1;
      display:grid;
      grid-template-columns:repeat(8,1fr);
      grid-template-rows:repeat(8,1fr);
      gap:2px;
      /* Mobilde s√ºr√ºklerken sayfa kaymasƒ±n diye: */
      touch-action: none; 
      background:#050015;
      border-radius:16px;
      padding:5px;
      user-select: none;
    }

    /* PATLAMA SIRASINDA SHAKE */
    .board.shake{
      animation:shake .18s ease-in-out;
    }
    @keyframes shake{
      0%{transform:translate(0,0);}
      25%{transform:translate(-2px,2px);}
      50%{transform:translate(2px,-2px);}
      75%{transform:translate(-1px,1px);}
      100%{transform:translate(0,0);}
    }

    .cell{
      position:relative;
      border-radius:10px;
      background:#050012; 
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      overflow:hidden; /* Patlama dƒ±≈üarƒ± ta≈ümasƒ±n derseniz hidden, ta≈üsƒ±n derseniz visible */
    }

    .gem{
      width:80%;
      height:80%;
      transform:scale(1);
      transition:transform .08s, opacity .08s;
      background-size:contain;
      background-position:center;
      background-repeat:no-repeat;
      pointer-events: none; /* Tƒ±klamalar cell'e gitsin */
    }

    /* RESIMLER */
    .r{background-image:url("meteor_red.png");}
    .g{background-image:url("meteor_green.png");}
    .y{background-image:url("meteor_yellow.png");}
    .s{background-image:url("meteor_gray.png");}

    .cell.selected .gem{
      transform:scale(1.15);
      filter:drop-shadow(0 0 8px rgba(255,255,255,.7));
    }
    
    /* Patlama animasyonu */
    .cell.pop .gem{
      animation:pop .2s forwards;
    }
    @keyframes pop{
      to{transform:scale(1.5);opacity:0;}
    }

    /* BOOM HALKASI */
    .cell.boom::after{
      content:"";
      position:absolute;
      left:50%;
      top:50%;
      width:10px;
      height:10px;
      transform:translate(-50%,-50%);
      border-radius:50%;
      pointer-events:none;
      background: radial-gradient(circle, #fff 0%, #ffce3a 40%, transparent 80%);
      opacity:0;
      z-index: 10;
    }
    /* 3+ E≈üle≈üince tetiklenen CSS class */
    .cell.boom.explode::after {
       animation: explosion .4s ease-out forwards;
    }

    @keyframes explosion{
      0% {
        transform:translate(-50%,-50%) scale(0.5);
        opacity:1;
      }
      50% {
        opacity: 0.8;
      }
      100%{
        transform:translate(-50%,-50%) scale(6);
        opacity:0;
      }
    }

    .hint{
      margin-top:6px;
      font-size:10px;
      text-align:center;
      opacity:.9;
      max-width:360px;
    }

    /* OVERLAY */
    .overlay{
      position:fixed;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      background:rgba(0,0,0,.95);
      padding:16px 24px;
      border-radius:16px;
      font-size:12px;
      line-height:1.5;
      box-shadow:0 0 30px rgba(255,206,58,0.2);
      display:none;
      text-align:center;
      z-index:50;
      border: 1px solid #333;
    }
    .overlay strong{color:#ffce3a;}
    .btn{
      margin-top:12px;
      padding:8px 16px;
      border-radius:999px;
      border:none;
      background:#ffce3a;
      color:#000;
      font-size:11px;
      font-weight:700;
      cursor:pointer;
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="title">
    <h1>Babypeacock Meteor Match</h1>
    <span>S√ºr√ºkle, patlat, k√∂peƒüi fini≈üe ula≈ütƒ±r.</span>
    <div class="badge">
      <span>Babypeacock universe</span>
      <span>¬∑</span>
      <strong>Swipe Modu</strong>
    </div>
  </div>

  <div class="race-wrap">
    <div class="race-label">
      <span>Meteor hedeflerini topla, k√∂pek ko≈üsun.</span>
      <span>ƒ∞lerleme: <strong id="progressText">0%</strong></span>
    </div>
    <div class="race-bar" id="raceBar">
      <div class="doge-marker" id="dogeMarker">
        <video src="Doge.mp4" autoplay loop muted playsinline></video>
      </div>
      <div class="finish-tag">FINISH</div>
    </div>
  </div>

  <div class="board-wrap">
    <div class="top-row">
      <div>Skor: <span id="score">0</span></div>
      <div>Hamle: <span id="moves">0</span></div>
    </div>

    <div class="targets">
      <span class="targets-title">Hedef:</span>
      <span class="target-pill">
        <span class="target-dot dot-r"></span>
        <span id="t_r">0/12</span>
      </span>
      <span class="target-pill">
        <span class="target-dot dot-y"></span>
        <span id="t_y">0/8</span>
      </span>
      <span class="targets-sub">3+ Patlama üí•</span>
    </div>

    <div class="board" id="board"></div>
    <div class="hint">
      Meteorlarƒ± <strong>s√ºr√ºkleyerek</strong> yer deƒüi≈ütir. En az 3 aynƒ± renk yan yana gelmeli.
    </div>
  </div>
</div>

<div class="overlay" id="overlay">
  <div id="overlayText"></div>
  <button class="btn" onclick="restart()">Tekrar Oyna</button>
</div>

<script>
/* ==== Meteor Match - Swipe Logic ==== */

const rows = 8;
const cols = 8;
const types = ['r','g','y','s']; // kƒ±rmƒ±zƒ±, ye≈üil, sarƒ±, gri

const MAX_MOVES = 25;
let movesLeft = MAX_MOVES;

// Hedefler
const targets = {
  r: 12,
  y: 8
};
let collected = { r:0, y:0 };

const boardEl = document.getElementById('board');
const scoreEl = document.getElementById('score');
const movesEl = document.getElementById('moves');
const overlay = document.getElementById('overlay');
const overlayText = document.getElementById('overlayText');
const dogeMarker = document.getElementById('dogeMarker');
const raceBar = document.getElementById('raceBar');
const progressText = document.getElementById('progressText');

const targetEls = {
  r: document.getElementById('t_r'),
  y: document.getElementById('t_y')
};

let board = [];
let selected = null; 
let animating = false;
let score = 0;
let progress = 0;
let gameOver = false;

// S√ºr√ºkleme deƒüi≈ükenleri
let startX = 0;
let startY = 0;
let startRow = null;
let startCol = null;

function init(){
  board = [];
  boardEl.innerHTML = '';
  score = 0;
  progress = 0;
  movesLeft = MAX_MOVES;
  gameOver = false;
  selected = null;
  animating = false;

  collected.r = 0;
  collected.y = 0;

  updateScore(0);
  updateMoves();
  updateTargetsUI();
  overlay.style.display = "none";

  for(let r=0;r<rows;r++){
    const row = [];
    for(let c=0;c<cols;c++){
      const t = randomType();
      row.push(t);
      const cell = createCell(r,c,t);
      boardEl.appendChild(cell);
    }
    board.push(row);
  }

  resolveBoard();  // Ba≈ülangƒ±√ßta hazƒ±r e≈üle≈üme olmasƒ±n
}

function randomType(){
  return types[Math.floor(Math.random()*types.length)];
}

function createCell(r,c,t){
  const cell = document.createElement('div');
  cell.className = 'cell';
  cell.dataset.r = r;
  cell.dataset.c = c;

  const gem = document.createElement('div');
  gem.className = 'gem ' + t;
  cell.appendChild(gem);

  // Pointer events for Touch & Mouse Drag
  cell.addEventListener('pointerdown', handleInputStart);
  cell.addEventListener('pointerup', handleInputEnd);
  // Mouse alan dƒ±≈üƒ±na √ßƒ±karsa diye √∂nlem (isteƒüe baƒülƒ±)
  cell.addEventListener('pointerleave', (e) => {
     // S√ºr√ºkleme ba≈üladƒ±ysa ve h√ºcreden √ßƒ±ktƒ±ysa hemen swipe'ƒ± tamamlamaya √ßalƒ±≈üabiliriz
     // Ancak pointerup genellikle yeterlidir. Basitlik i√ßin pointerup kullanƒ±yoruz.
  });

  return cell;
}

/* ==== S√úR√úKLEME (DRAG / SWIPE) MANTIƒûI ==== */

function handleInputStart(e) {
  if(animating || gameOver) return;
  // Varsayƒ±lan s√ºr√ºklemeyi engelle (resim s√ºr√ºklenmesin)
  e.preventDefault();

  // Ba≈ülangƒ±√ß koordinatlarƒ±
  startX = e.clientX;
  startY = e.clientY;
  
  // Hangi h√ºcrede ba≈üladƒ±k
  startRow = parseInt(e.currentTarget.dataset.r);
  startCol = parseInt(e.currentTarget.dataset.c);

  // G√∂rsel se√ßim efekti (Tƒ±klama modu i√ßin de ge√ßerli)
  // Eski se√ßimi temizle
  if(selected) {
     getCell(selected.r, selected.c).classList.remove('selected');
  }
  selected = {r: startRow, c: startCol};
  e.currentTarget.classList.add('selected');
}

function handleInputEnd(e) {
  if(animating || gameOver || startRow === null) return;

  const endX = e.clientX;
  const endY = e.clientY;
  
  const diffX = endX - startX;
  const diffY = endY - startY;

  // S√ºr√ºkleme hassasiyeti (piksel)
  const threshold = 20;

  // Eƒüer hareket √ßok k√º√ß√ºkse -> Tƒ±klama (Tap) olarak kabul et
  if(Math.abs(diffX) < threshold && Math.abs(diffY) < threshold) {
     // Burasƒ± sadece tƒ±klama ile oynayanlar i√ßin. 
     // ƒ∞kinci bir ta≈üa tƒ±klandƒ±ysa handleTapLogic √ßaƒürƒ±labilir.
     // ≈ûu anki yapƒ±da sadece se√ßili bƒ±rakƒ±yoruz, yanƒ±na tƒ±klarsa o zaman i≈ülem yapabiliriz.
     // Ancak biz SWIPE odaklƒ±yƒ±z, o y√ºzden drag olmadƒ±ysa bir ≈üey yapma.
     return; 
  }

  // Yeterince b√ºy√ºk hareket var, y√∂n√º bulalƒ±m
  let targetRow = startRow;
  let targetCol = startCol;

  if(Math.abs(diffX) > Math.abs(diffY)) {
    // Yatay hareket
    if(diffX > 0) targetCol++; // Saƒü
    else targetCol--;          // Sol
  } else {
    // Dikey hareket
    if(diffY > 0) targetRow++; // A≈üaƒüƒ±
    else targetRow--;          // Yukarƒ±
  }

  // Tahta sƒ±nƒ±rlarƒ± i√ßinde mi?
  if(targetRow >= 0 && targetRow < rows && targetCol >= 0 && targetCol < cols) {
    // Se√ßimi temizle
    if(selected) {
      getCell(selected.r, selected.c).classList.remove('selected');
      selected = null;
    }
    swapAndCheck(startRow, startCol, targetRow, targetCol);
  } else {
    // Sƒ±nƒ±r dƒ±≈üƒ± hamle, se√ßimi bƒ±rak
    if(selected) {
      getCell(selected.r, selected.c).classList.remove('selected');
      selected = null;
    }
  }

  // Reset
  startRow = null;
  startCol = null;
}

/* Eski tƒ±klama mantƒ±ƒüƒ±nƒ± da desteklemek isterseniz bu fonksiyonu pointerup i√ßinde 'threshold altƒ±ndaysa' √ßaƒüƒ±rabilirsiniz. 
   ≈ûimdilik sadece swipe ile devam ediyoruz, kullanƒ±cƒ± deneyimi daha akƒ±cƒ± olur. */

function getCell(r,c){
  return boardEl.children[r*cols + c];
}

function swapTypes(r1,c1,r2,c2){
  const tmp = board[r1][c1];
  board[r1][c1] = board[r2][c2];
  board[r2][c2] = tmp;
}

function refreshVisual(){
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const cell = getCell(r,c);
      // classList ile oynamak yerine temizliyoruz ama 'boom' efektleri kaybolabilir.
      // Sadece gem'i g√ºncelleyelim:
      const gem = cell.querySelector('.gem');
      gem.className = 'gem ' + board[r][c];
      gem.style.opacity = 1;
      gem.style.transform = 'scale(1)';
      
      // Cell √ºzerindeki animasyon classlarƒ±nƒ± temizle
      cell.classList.remove('pop', 'boom', 'explode'); 
    }
  }
}

function swapAndCheck(r1,c1,r2,c2){
  animating = true;
  
  // G√∂rsel olarak swap yapmadan √∂nce veri deƒüi≈üimi
  swapTypes(r1,c1,r2,c2);
  
  // Basit bir CSS transform ile deƒüi≈üim animasyonu yapƒ±labilir ama
  // burada hƒ±zlƒ±ca refreshVisual kullanƒ±yoruz, match-3 standardƒ±.
  refreshVisual();

  const matches = findMatches();
  if(matches.length === 0){
    // E≈üle≈üme yok, geri al
    setTimeout(()=>{
      swapTypes(r1,c1,r2,c2);
      refreshVisual();
      animating = false;
      // Hatalƒ± hamle efekti eklenebilir (titreme vb)
    }, 200);
  }else{
    movesLeft--;
    if(movesLeft<0) movesLeft = 0;
    updateMoves();
    handleMatches(matches);
  }
}

function findMatches(){
  const toClear = [];

  // Yatay
  for(let r=0;r<rows;r++){
    let count = 1;
    for(let c=1;c<=cols;c++){
      const curr = c<cols ? board[r][c] : null;
      const prev = board[r][c-1];
      if(curr && curr === prev){
        count++;
      }else{
        if(count>=3){
          for(let k=0;k<count;k++){
            toClear.push({r, c:c-1-k});
          }
        }
        count = 1;
      }
    }
  }

  // Dikey
  for(let c=0;c<cols;c++){
    let count = 1;
    for(let r=1;r<=rows;r++){
      const curr = r<rows ? board[r][c] : null;
      const prev = board[r-1][c];
      if(curr && curr === prev){
        count++;
      }else{
        if(count>=3){
          for(let k=0;k<count;k++){
            toClear.push({r:r-1-k, c});
          }
        }
        count = 1;
      }
    }
  }

  // Tekrar edenleri temizle
  const seen = new Set();
  const unique = [];
  for(const p of toClear){
    const key = p.r + '-' + p.c;
    if(!seen.has(key)){
      seen.add(key);
      unique.push(p);
    }
  }
  return unique;
}

function handleMatches(matches){
  if(matches.length === 0){
    animating = false;
    return;
  }

  const typeCount = {};
  matches.forEach(p=>{
    const t = board[p.r][p.c];
    if(!typeCount[t]) typeCount[t] = 0;
    typeCount[t]++;

    const cell = getCell(p.r,p.c);
    // Patlama classlarƒ±
    cell.classList.add('pop', 'boom', 'explode');
  });

  // Tahta titret
  boardEl.classList.add('shake');

  // Puan hesapla
  const n = matches.length;
  // Biraz daha tatmin edici puanlama
  const gain = n * 10 + (n > 3 ? (n-3)*20 : 0); 
  updateScore(score + gain);

  for(const t in typeCount){
    if(targets[t] != null){
      collected[t] += typeCount[t];
    }
  }
  updateTargetsUI();

  // Animasyon s√ºresi kadar bekle
  setTimeout(()=>{
    boardEl.classList.remove('shake');

    matches.forEach(p=>{
      board[p.r][p.c] = null; // Bo≈üalt
    });

    // Yukarƒ±dan ta≈ü d√º≈ü√ºrme
    for(let c=0;c<cols;c++){
      let writeRow = rows - 1;
      for(let r=rows-1;r>=0;r--){
        if(board[r][c]){
          board[writeRow][c] = board[r][c];
          if(writeRow !== r) board[r][c] = null;
          writeRow--;
        }
      }
      for(let r=writeRow;r>=0;r--){
        board[r][c] = randomType();
      }
    }

    refreshVisual(); // Yeni durumu √ßiz

    // Zincirleme reaksiyon kontrol√º
    const more = findMatches();
    if(more.length>0){
      // Biraz bekle sonra zincirleme patlat
      setTimeout(() => handleMatches(more), 250);
    }else{
      animating = false;
      if(!gameOver && movesLeft<=0 && progress<1){
        showLose();
      }
    }
  }, 400); // Patlama animasyonu biti≈ü s√ºresi
}

function updateScore(v){
  score = v;
  scoreEl.textContent = score;
}

function updateMoves(){
  movesEl.textContent = movesLeft;
}

function updateTargetsUI(){
  let totalNeeded = 0;
  let totalDone = 0;

  for(const key in targets){
    totalNeeded += targets[key];
    const done = Math.min(collected[key], targets[key]);
    totalDone += done;

    if(targetEls[key]){
      targetEls[key].textContent = done + "/" + targets[key];
    }
  }

  progress = totalNeeded ? totalDone / totalNeeded : 0;
  updateProgress(progress);

  if(progress >= 1 && !gameOver){
    // Kazanma durumunda biraz bekle, son patlama g√∂r√ºns√ºn
    setTimeout(() => {
       showWin("Harika! Hedefler tamam, k√∂pek fini≈üi ge√ßti! üêïüöÄ");
    }, 500);
  }
}

function updateProgress(p){
  const percent = Math.round(p * 100);
  progressText.textContent = percent + "%";
  // Marker hareketi
  // raceBar geni≈üliƒüi - k√∂pek geni≈üliƒüi - padding
  if(raceBar && dogeMarker){
      const maxMove = raceBar.clientWidth - dogeMarker.offsetWidth - 20;
      dogeMarker.style.transform = `translateX(${maxMove * p}px)`;
  }
}

function showWin(msg){
  if(gameOver) return;
  gameOver = true;
  overlayText.innerHTML = msg;
  overlay.style.display = "block";
}

function showLose(){
  if(gameOver) return;
  gameOver = true;
  overlayText.innerHTML =
    "Hamleler bitti üòî<br>Meteor hedeflerini tamamlayamadƒ±n.";
  overlay.style.display = "block";
}

function restart(){
  init();
}

function resolveBoard(){
  let more = findMatches();
  let guard = 0;
  while(more.length>0 && guard < 50){
    more.forEach(p=>{ board[p.r][p.c] = randomType(); });
    more = findMatches();
    guard++;
  }
  refreshVisual();
}

/* BA≈ûLAT */
init();
</script>
</body>
</html>
